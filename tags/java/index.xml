<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on A guy with &#39;Ego&#39; in his name</title>
    <link>https://bsideup.github.io/tags/java/</link>
    <description>Recent content in Java on A guy with &#39;Ego&#39; in his name</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 08 Apr 2019 15:52:05 +0200</lastBuildDate>
    
	<atom:link href="https://bsideup.github.io/tags/java/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>How to locally debug containers started by Testcontainers</title>
      <link>https://bsideup.github.io/posts/debugging_containers/</link>
      <pubDate>Mon, 08 Apr 2019 15:52:05 +0200</pubDate>
      
      <guid>https://bsideup.github.io/posts/debugging_containers/</guid>
      <description>One of the best things Docker gave us was the port randomization. You no longer have to care about the conflicts, especially on CI environments.
But it also created a big confusion for many users who got used to Redis on port 6379, or Java debugger on 5005. Many tools are not container aware and expect things on static ports.
Well, we can&amp;rsquo;t change the whole world (yet), but maybe there is something we can do for the Testcontainers users?</description>
    </item>
    
    <item>
      <title>The Builder pattern vs Java syntax</title>
      <link>https://bsideup.github.io/posts/builders_vs_java/</link>
      <pubDate>Thu, 31 Jan 2019 13:29:11 +0100</pubDate>
      
      <guid>https://bsideup.github.io/posts/builders_vs_java/</guid>
      <description>The Builder pattern is one of the most popular patterns in Java.
It is simple, helps to keep objects immutable, and can be generated with tools like Project Lombok&amp;rsquo;s @Builder or Immutables, to name a few.
Example of a fluent variant of the pattern:
public class User { private final String firstName; private final String lastName; User(String firstName, String lastName) { this.firstName = firstName; this.lastName = lastName; } public static Builder builder() { return new Builder(); } public static class Builder { String firstName; String lastName; Builder firstName(String value) { this.</description>
    </item>
    
    <item>
      <title>My favourite GitHub bots</title>
      <link>https://bsideup.github.io/posts/github_bots/</link>
      <pubDate>Wed, 23 Jan 2019 13:58:43 +0100</pubDate>
      
      <guid>https://bsideup.github.io/posts/github_bots/</guid>
      <description>Year 2018 was an eye-opening year for me as an OSS project maintainer. The reason is due to the emerge of GitHub bots.
Maintaining a project on GitHub could be a challenging task, especially when the project becomes popular. Issue management, releases, follow-ups, dependency management, oh my!
But, as most of the developers, we&amp;rsquo;re lazy enough and spend time automating things.
Dependabot https://github.com/apps/dependabot
There are many nice bots, but Dependabot is a real &amp;ldquo;Good Boy Bot&amp;rdquo;!</description>
    </item>
    
    <item>
      <title>Easy Java delegates with Lombok</title>
      <link>https://bsideup.github.io/posts/easy_java_delegates/</link>
      <pubDate>Fri, 04 Jan 2019 15:17:30 +0100</pubDate>
      
      <guid>https://bsideup.github.io/posts/easy_java_delegates/</guid>
      <description>Ever wanted to override a method of an object instance in Java?
Let&amp;rsquo;s say you want to implement a custom Scheduler hook for Project Reactor. You start with Schedulers.addExecutorServiceDecorator, implement a BiFunction accepting Scheduler&amp;rsquo;s instance and ScheduledExecutorService and you need to return another ScheduledExecutorService instance where schedule* methods wrapped with your code.
A straightforward approach would be to create a new class, implement all methods of ScheduledExecutorService interface, and delegate most of them to the instance of ScheduledExecutorService we received as an argument.</description>
    </item>
    
    <item>
      <title>JNI cross-compilation with Docker</title>
      <link>https://bsideup.github.io/posts/jni-cross-compilation/</link>
      <pubDate>Wed, 26 Dec 2018 17:56:42 +0100</pubDate>
      
      <guid>https://bsideup.github.io/posts/jni-cross-compilation/</guid>
      <description>As a JVM guy, I got used to &amp;ldquo;write once, run everywhere&amp;rdquo; paradigm. But recently I got an interesting challenge to solve.
I was working on a debugging tool for Project Reactor and part of it is implemented as a native library for Java, using JNI technology.
I did some C++ in the past but never thought how hard is it, to cross-compile a library for 3 major platforms (Windows, Linux and Mac), both locally and on CI environment (from where we perform the releases).</description>
    </item>
    
  </channel>
</rss>