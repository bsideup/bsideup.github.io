<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Testcontainers on A guy with &#39;Ego&#39; in his name</title>
    <link>https://bsideup.github.io/tags/testcontainers/</link>
    <description>Recent content in Testcontainers on A guy with &#39;Ego&#39; in his name</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Fri, 10 Jul 2020 14:22:31 +0200</lastBuildDate>
    
	<atom:link href="https://bsideup.github.io/tags/testcontainers/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Trying Rootless Docker with Testcontainers</title>
      <link>https://bsideup.github.io/posts/rootless_docker/</link>
      <pubDate>Fri, 10 Jul 2020 14:22:31 +0200</pubDate>
      
      <guid>https://bsideup.github.io/posts/rootless_docker/</guid>
      <description>Rootless Docker is one of the most exciting recent changes in the Docker ecosystem.
It allows you to run the same good old Docker but without having to obtain root privileges on the machine.
Installing Rootless Docker on a fresh VM Although you can run Rootless Docker-in-Docker, I wanted to try it on a fresh environment.
A few seconds later, I had an Ubuntu VM running on Oracle Cloud to play with:</description>
    </item>
    
    <item>
      <title>Local development with Testcontainers</title>
      <link>https://bsideup.github.io/posts/local_development_with_testcontainers/</link>
      <pubDate>Tue, 11 Feb 2020 13:29:47 +0100</pubDate>
      
      <guid>https://bsideup.github.io/posts/local_development_with_testcontainers/</guid>
      <description>Testcontainers is a very helpful library when it comes to integration testing.
One of the main benefits of it is that you can code your &amp;ldquo;dependencies&amp;rdquo; (like databases, brokers, cloud mocks, and other I/O sources) and start them with Docker from your tests - no need to run any additional command like docker-compose up or anything!
But sometimes it is still useful to start your application and play with it.</description>
    </item>
    
    <item>
      <title>E2E test your Spring Boot 2.3.0 apps with Testcontainers</title>
      <link>https://bsideup.github.io/posts/spring_boot_in_container/</link>
      <pubDate>Thu, 30 Jan 2020 14:43:14 +0100</pubDate>
      
      <guid>https://bsideup.github.io/posts/spring_boot_in_container/</guid>
      <description>Spring Boot 2.3.0.M1 comes with a number of great features. I find one of them especially interesting - now you can build layered Docker images using Cloud Native Buildpacks!
It is a very fast way of building Docker images compared to the Dockerfile approach thanks to Buildpacks.
It is so fast that we can use it&amp;hellip; to build, start and test our service as a Docker container (with Testcontainers, of course!</description>
    </item>
    
    <item>
      <title>Why you should never use fixed ports in your Testcontainers tests</title>
      <link>https://bsideup.github.io/posts/testcontainers_fixed_ports/</link>
      <pubDate>Mon, 27 Jan 2020 12:23:19 +0100</pubDate>
      
      <guid>https://bsideup.github.io/posts/testcontainers_fixed_ports/</guid>
      <description>I admit it - people are used to static ports. Web server? port 80! Redis? 6379! Java app? 8080!
But let&amp;rsquo;s be honest, the following also looks painfully familiar:
Bind for 0.0.0.0:80 failed: port is already allocated. But there is more - localhost is the king!
There was some disturbance back in the days of docker-machine (magical 192.168.99.100, anyone? Heck, I even wrote a tool that auto-forwards ports to localhost), but people really think everything they start on from their machine should be on localhost.</description>
    </item>
    
    <item>
      <title>How to locally debug containers started by Testcontainers</title>
      <link>https://bsideup.github.io/posts/debugging_containers/</link>
      <pubDate>Mon, 08 Apr 2019 15:52:05 +0200</pubDate>
      
      <guid>https://bsideup.github.io/posts/debugging_containers/</guid>
      <description>One of the best things Docker gave us was the port randomization. You no longer have to care about possible conflicts, especially on CI environments.
But it also created a big confusion for many users who got used to Redis listening on port 6379, or the Java debugger on 5005. Many tools are not container aware and expect things on static ports.
Well, we can&amp;rsquo;t change the whole world (yet), but maybe there is something we can do for the Testcontainers users?</description>
    </item>
    
    <item>
      <title>The Builder pattern vs Java syntax</title>
      <link>https://bsideup.github.io/posts/builders_vs_java/</link>
      <pubDate>Thu, 31 Jan 2019 13:29:11 +0100</pubDate>
      
      <guid>https://bsideup.github.io/posts/builders_vs_java/</guid>
      <description>The Builder pattern is one of the most popular patterns in Java.
It is simple, helps to keep objects immutable, and can be generated with tools like Project Lombok&amp;rsquo;s @Builder or Immutables, to name a few.
Example of a fluent variant of the pattern:
public class User { private final String firstName; private final String lastName; User(String firstName, String lastName) { this.firstName = firstName; this.lastName = lastName; } public static Builder builder() { return new Builder(); } public static class Builder { String firstName; String lastName; Builder firstName(String value) { this.</description>
    </item>
    
    <item>
      <title>My favourite GitHub bots</title>
      <link>https://bsideup.github.io/posts/github_bots/</link>
      <pubDate>Wed, 23 Jan 2019 13:58:43 +0100</pubDate>
      
      <guid>https://bsideup.github.io/posts/github_bots/</guid>
      <description>Year 2018 was an eye-opening year for me as an OSS project maintainer. The reason is due to the emerge of GitHub bots.
Maintaining a project on GitHub could be a challenging task, especially when the project becomes popular. Issue management, releases, follow-ups, dependency management, oh my!
But, as most of the developers, we&amp;rsquo;re lazy enough and spend time automating things.
Dependabot https://github.com/apps/dependabot
There are many nice bots, but Dependabot is a real &amp;ldquo;Good Boy Bot&amp;rdquo;!</description>
    </item>
    
  </channel>
</rss>